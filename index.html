<!DOCTYPE html>
<html>
	<head>
		<title>da</title>
<style>
* {
	touch-action: none;
}

canvas {
	width: 100%;
	height: 90vh;
}
</style>
	</head>
	<body>
		<canvas id="screen"></canvas>
	</body>
	<script src="input.js"></script>
	<script src="graphics.js"></script>
	<script src="qtree.js"></script>
	<script>
let screen = document.getElementById("screen");
let gl = screen.getContext("webgl");

let rend = FragmentRenderer(gl,
`
precision highp float;

uniform vec2 tres;
uniform sampler2D tex;

uniform vec2 center;
uniform int node;
uniform int depth;
uniform float unit;


uniform mat4 transform;

vec2 moddiv(int a, int b){
	int div = a / b;
	int mod = a - div * b;

	return vec2(mod, div);
}

int vec4toint(vec4 val){
	return int(256.0*val.r) + int(256.0*256.0*val.g) + int(256.0*256.0*256.0*val.b) + int(256.0*256.0*256.0*256.0*val.a);
}

vec4 col_at(int ind){
	vec2 tc = moddiv(ind, int(tres.x)) / tres;
	tc.y = 1.0 - tc.y;
	return texture2D(tex, tc);
}

int num_at(int ind){
	vec2 tc = moddiv(ind, int(tres.x)) / tres;
	tc.y = 1.0 - tc.y;
	return vec4toint(texture2D(tex, tc));
}



void main(){
	vec2 pos = (transform * vec4(gl_FragCoord.xy, 0.0, 1.0)).xy;
	vec2 orig = center;

	int ind = node;
	float width = unit;

	if(any(greaterThan(abs(pos - orig), vec2(width*0.5))))
		discard;

	for(int i = 0; i < 16; i++){
		if(i >= depth)
			break;

		vec2 quad = vec2(pos.x > orig.x, pos.y < orig.y);
		ind = num_at(ind * 5 + 1 + int(quad.x + 2.0*quad.y));
		width = width / 2.0;
		orig = vec2(quad.x-0.5, 0.5-quad.y)*width + orig;
	}

	gl_FragColor = col_at(ind*5);
	gl_FragColor.a = 1.0;
}
`
);




let set_qtree = (qtree, node) => {
	let buffer = qtree.get_buffer();
	let tex_w = Math.min(gl.getParameter(gl.MAX_TEXTURE_SIZE)/4, 1<<12);
	let num = buffer.length / 4;
	let [w, h] = num < tex_w ? [num, 1] : [tex_w, num / tex_w];

	rend.set_texture("tex", w, h, buffer);
	rend.set_uniform("tres", "vec2", [w, h]);
	rend.set_uniform("node", "int", node.ind);
}

let add = (a, b) => a.map((v, i) => v + b[i]);
let smul = (a, b) => b.map(v => v * a);
let sub = (a, b) => add(a, smul(-1, b));
let dot = (a, b) => a.map((v, i) => v * b[i]).reduce((a, b) => a + b);
let length = (a) => dot(a, a)**0.5;
let norm = (a) => smul(1/length(a), a);
let to_cspace = ([x, y]) => [x - screen.width/2, screen.height/2 - y];






/*TODO remove globals*/
let unit;
let pos = [0, 0];
let zoom = 1;
let path = [0n, 0n];
let c_depth = 1n;
let c_tree;
let redraw = false;

let get_location = () => {
	return `[${pos}], ${zoom}, [${path[0]}n, ${path[1]}n], ${c_depth}n`;
}

let get_tlnode = () => {
	let mask = ~((1n<<c_depth)-1n);

	let path_arr = [
		add(path, [0n, 0n]),
		add(path, [1n, 0n]),
		add(path, [0n, 1n]),
		add(path, [1n, 1n]),
	];

	while(path_arr.flat().some(v => v & mask)){
		let nodes = [white, white, white, white];
		let ind = BigInt((path[0] < 0n) + 2*(path[1] < 0n));

		nodes[ind] = c_tree;
		c_tree = qtree.add_node(0xffffffff, ...nodes);

		let os = smul(1n<<c_depth, [ind&1n,ind>>1n]);

		path_arr = path_arr.map(v => add(v, os));

		path = add(path, os);
		c_depth++;
		mask <<= 1n;
	}

	return qtree.add_node(0xffffffff, ...path_arr.map(v => get_node(c_tree, v, c_depth)));
}


let update_view = (n_pos, n_zoom, n_path, n_depth) => {
	while(1 >= 4*n_zoom){
		n_zoom *= 2;

		n_depth++;
		n_path = add(smul(2n, path), [1n, 1n]);
	}

	while(1 <= n_zoom){
		n_zoom /= 2;

		let os = smul(unit/n_zoom/4, [!(path[0] & 1n), -!(path[1] & 1n)]);
		n_pos = add(n_pos, os);

		n_depth--;
		n_path = [path[0]>>1n, path[1]>>1n];
	}

	let v = smul(-4*n_zoom/unit, n_pos).map(v => Math.sign(v | 0));
	if(v[0] || v[1]){
		n_pos = add(n_pos, smul(unit/(n_zoom*2), v));
		n_path = add(n_path, [BigInt(v[0]), BigInt(-v[1])]);
	}

	let update_tree = false;
	if(n_depth != c_depth || add(path, smul(-1n, n_path)).some(v => v != 0n)){
		update_tree = true;
	}

	pos = n_pos;
	zoom = n_zoom;
	path = n_path;
	c_depth = n_depth;

	if(update_tree)
		set_qtree(qtree, get_tlnode());

	redraw = true;
}

/* event listeners */
mouse_wheel(screen, ([x, y], change) => {
	let dp = to_cspace([x, y]);
	let n_zoom = zoom + 0.05*zoom*change;

	update_view(
		add(smul(zoom/n_zoom, sub(pos, dp)), dp),
		n_zoom,
		path, 
		c_depth
	);
});
touch_pinch(screen, ([x, y], change) => {
	let dp = to_cspace([x, y]);
	let n_zoom = zoom + 0.05*zoom*change;

	update_view(
		add(smul(zoom/n_zoom, sub(pos, dp)), dp),
		n_zoom,
		path, 
		c_depth
	);
});


mouse_pan(screen, () => pos, (n_pos) => update_view(n_pos, zoom, path, c_depth));
touch_pan(screen, () => pos, (n_pos) => update_view(n_pos, zoom, path, c_depth));

screen.addEventListener("contextmenu", (e) => e.preventDefault());

let update_screen = () => {
	let n_dim = [screen.clientWidth, screen.clientHeight];

	[screen.width, screen.height] = n_dim;
	gl.viewport(0, 0, ...n_dim);
	unit = 2*Math.max(...n_dim);
	rend.set_uniform("center", "vec2", smul(0.5, n_dim));
	rend.set_uniform("depth", "int", Math.log2(unit) + 4 | 0);

	redraw = true;
}

addEventListener("resize", update_screen);





let loop = () => {

	if(redraw){
		redraw = false;
		rend.set_uniform("transform", "mat4", [
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			-pos[0], -pos[1], 0, 1
		]);

		rend.set_uniform("unit", "float", unit/zoom);
		rend.draw();
	}

	requestAnimationFrame(loop);
}









/*init tree*/
let qtree = LinearQtree();

let black = qtree.add_node(0, {ind: 0}, {ind: 0}, {ind: 0}, {ind: 0});
let white = qtree.add_node(0xffffffff, {ind: 1}, {ind: 1}, {ind: 1}, {ind: 1});
let cyan = qtree.add_node(0x00ffff00, {ind: 2}, {ind: 2}, {ind: 2}, {ind: 2});

{
  let a = qtree.add_node(0xffffffff, 0, 0, 0, cyan);
  let b = qtree.add_node(0xffffffff, 0, 0, 0, white);
  let t45 = qtree.add_node(0xffffffff, b, b, b, black);

  a.set_node(0, t45);
  a.set_node(1, a);
  a.set_node(2, b);
  a.set_tag(0xffffffff);

  b.set_node(0, t45);
  b.set_node(1, b);
  b.set_node(2, a);
  b.set_tag(0xffff00ff);

  tree = t45
}

c_tree = tree;
update_screen();
set_qtree(qtree, tree);
loop();
	</script>
</html>
