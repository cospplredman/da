<!DOCTYPE html>
<html>
	<head>
		<title>da</title>
<style>
* {
	touch-action: none;
}

body {
	width: 100vw;
	height: 100vh;
	margin: 0;
	padding: 0;
	border: 0;
	overflow: hidden;
}

canvas {
	width: 100%;
	height: 100%;
}
</style>
	</head>
	<body>
		<canvas id="screen"></canvas>
	</body>
	<script src="input.js"></script>
	<script src="graphics.js"></script>
	<script src="qtree.js"></script>
	<script>
let screen = document.getElementById("screen");
let gl = screen.getContext("webgl");

let rend = FragmentRenderer(gl,
`
precision highp float;
precision highp int;

uniform vec2 res;


uniform vec2 tres;
uniform int ltwidth;
uniform sampler2D tex;

uniform vec2 center;
uniform ivec4 node;
uniform int depth;
uniform float unit;


uniform mat4 transform;

/* 32bit int emulation */
ivec2 moddiv(int a, int b){
	int div = int(a / b);
	int mod = int(a - div * b);

	return ivec2(mod, div);
}

ivec4 carry_prop(ivec4 a){
	ivec2 v;

	v = moddiv(a.r, 256);
	a.r = v.x;
	v = moddiv(a.g + v.y, 256);
	a.g = v.x;
	v = moddiv(a.b + v.y, 256);
	a.b = v.x;
	v = moddiv(a.a + v.y, 256);
	a.a = v.x;

	return a;
}

ivec4 rshift8(ivec4 a){
	return ivec4(a.g, a.b, a.a, 0);
}

ivec4 rshift07(ivec4 a, int b){
	int v = int(float(a.r) * pow(0.5, float(b)));
	a = carry_prop(rshift8(a)*int(pow(2.0,float(8-b))));
	a.r = a.r + v;
	return a;
}

ivec4 rshift(ivec4 a, int b){
	ivec2 mul = moddiv(b, 7);
	for(int i = 0; i < 8; i++){
		if(mul.y - i == 0)
			break;
		a = rshift07(a, 7);
	}

	return rshift07(a, mul.x);
}

ivec4 lshift(ivec4 a, int b){
	ivec2 mul = moddiv(b, 7);
	for(int i = 0; i < 8; i++){
		if(mul.y - i == 0)
			break;
		a = carry_prop(a*int(pow(2.0, 7.0)));
	}

	return carry_prop(a*int(pow(2.0, float(mul.x))));
}

ivec4 vec4tonum(vec4 val){
	return ivec4(int(255.0*val.r), int(255.0*val.g), int(255.0*val.b), int(255.0*val.a));
}


vec4 col_at(ivec4 ind){
	ivec4 v2 = rshift(ind, ltwidth);
	ivec4 v1 = ind - lshift(v2, ltwidth);

	vec2 tc = (vec2(v1.r + 256*v1.g, v2.r + 256*v2.g) + vec2(0.5)) / tres;
	return texture2D(tex, tc);
}

ivec4 num_at(ivec4 ind){
	return vec4tonum(col_at(ind));
}



void main(){
	vec2 pos = (transform * vec4(gl_FragCoord.xy, 0.0, 1.0)).xy;
	vec2 orig = center;

	ivec4 ind = node;
	float width = unit;

	for(int i = 0; i < 16; i++){
		if(i >= depth)
			break;

		vec2 quad = vec2(pos.x > orig.x, pos.y < orig.y);
		ind = ind * 5;
		ind.r = ind.r + 1 + int(quad.x + 2.0*quad.y);
		ind = num_at(carry_prop(ind));

		width = width / 2.0;
		orig = vec2(quad.x-0.5, 0.5-quad.y)*width + orig;
	}

	gl_FragColor = col_at(ind*5);
	gl_FragColor.a = 1.0;
}
`
);



let add = (a, b) => a.map((v, i) => v + b[i]);
let smul = (a, b) => b.map(v => v * a);
let sub = (a, b) => add(a, smul(-1, b));
let dot = (a, b) => a.map((v, i) => v * b[i]).reduce((a, b) => a + b);
let length = (a) => dot(a, a)**0.5;
let norm = (a) => smul(1/length(a), a);
let to_cspace = ([x, y]) => [x - screen.width/2, screen.height/2 - y];



/*TODO remove globals*/
let unit;
let pos = [0, 0];
let zoom = 1;
let path = [0n, 0n];
let c_depth = 1n;
let c_tree;

let tree_dirty = false;
let tree;

let redraw = false;
let update_tree = false;

let get_path = ([x, y], depth) => {
	let p = sub([x, screen.height - y], pos);
	let orig = [screen.width/2, screen.height/2];
	let width = unit/zoom;

	let pa = [0n, 0n]
	let de = 0n;

	for(let i = 0; i < depth; i++){
		quad = [p[0] > orig[0], p[1] < orig[1]];

		pa = [
			BigInt(quad[0]) + 2n*pa[0], 
			BigInt(quad[1]) + 2n*pa[1]
		];

		de++;
		width /= 2;
		orig = add(smul(width, [quad[0]-0.5, 0.5-quad[1]]), orig);
	}

	return [pa, de];
}

let set_qtree = (node) => {
	let depth = Math.log2(unit) + 4 | 0;
	let [tree, t_node] = sub_tree(node, depth);
	let buffer = tree.get_buffer();

	let num = Math.log2(buffer.length / 4);
	let [w, h] = [(num / 2 | 0) + (num & 1), num / 2 | 0];

	rend.set_texture("tex", 2**w, 2**h, buffer);
	rend.set_uniform("ltwidth", "int", w);
	rend.set_uniform("tres", "vec2", [2**w, 2**h]);
	rend.set_uniform("depth", "int", depth);
	rend.set_uniform("node", "ivec4", [
		(t_node.ind >> 0) & 0xff,
		(t_node.ind >> 8) & 0xff,
		(t_node.ind >> 16) & 0xff,
		(t_node.ind >> 24) & 0xff
	]);
}

let get_location = () => {
	return `[${pos}], ${zoom}, [${path[0]}n, ${path[1]}n], ${c_depth}n`;
}

let get_tlnode = () => {
	let mask = ~((1n<<c_depth)-1n);

	let path_arr = [
		add(path, [0n, 0n]),
		add(path, [1n, 0n]),
		add(path, [0n, 1n]),
		add(path, [1n, 1n]),
	];

	while(path_arr.flat().some(v => v & mask)){
		let nodes = Array(4).fill(qtree.color(0xffffffff));
		let ind = BigInt((path[0] < 0n) + 2*(path[1] < 0n));

		nodes[ind] = c_tree;
		c_tree = qtree.node(...nodes);

		let os = smul(1n<<c_depth, [ind&1n,ind>>1n]);

		path_arr = path_arr.map(v => add(v, os));

		path = add(path, os);
		c_depth++;
		mask <<= 1n;
	}

	return qtree.node(...path_arr.map(v => get_node(c_tree, v, c_depth)));
}


let update_view = (n_pos, n_zoom, n_path, n_depth) => {
	while(1 >= 4*n_zoom){
		n_zoom *= 2;

		n_depth++;
		n_path = add(smul(2n, path), [1n, 1n]);
	}

	while(1 < n_zoom){
		n_zoom /= 2;

		let os = smul(unit/n_zoom/4, [!(path[0] & 1n), -!(path[1] & 1n)]);
		n_pos = add(n_pos, os);

		n_depth--;
		n_path = [path[0]>>1n, path[1]>>1n];
	}

	let v = smul(-4*n_zoom/unit, n_pos).map(v => Math.sign(v | 0));
	if(v[0] || v[1]){
		n_pos = add(n_pos, smul(unit/(n_zoom*2), v));
		n_path = add(n_path, [BigInt(v[0]), BigInt(-v[1])]);
	}

	if(n_depth != c_depth || add(path, smul(-1n, n_path)).some(v => v != 0n)){
		update_tree = true;
	}

	if(tree_dirty && update_tree){
		let path_arr = [
			add(path, [0n, 0n]),
			add(path, [1n, 0n]),
			add(path, [0n, 1n]),
			add(path, [1n, 1n]),
		];

		path_arr.map((v, i) => {
			c_tree = replace_node(qtree, c_tree, v, c_depth, tree.get_node(i));
		});

		tree_dirty = false;
	}

	pos = n_pos;
	zoom = n_zoom;
	path = n_path;
	c_depth = n_depth;

	redraw = true;
	if(update_tree){

		tree = get_tlnode();
	}

}

/* event listeners */
mouse_wheel(screen, ([x, y], change) => {
	let dp = to_cspace([x, y]);
	let n_zoom = zoom + 0.05*zoom*change;

	update_view(
		add(smul(zoom/n_zoom, sub(pos, dp)), dp),
		n_zoom,
		path, 
		c_depth
	);
});
touch_pinch(screen, ([x, y], change) => {
	let dp = to_cspace([x, y]);
	let n_zoom = zoom + 0.05*zoom*change;

	update_view(
		add(smul(zoom/n_zoom, sub(pos, dp)), dp),
		n_zoom,
		path, 
		c_depth
	);
});

mouse_pan(screen, () => pos, (n_pos) => update_view(n_pos, zoom, path, c_depth));
touch_pan(screen, () => pos, (n_pos) => update_view(n_pos, zoom, path, c_depth));

pointer_drag(screen, (p) => {
	let path = get_path(p, 8);
	tree = replace_node(qtree, tree, ...path, qtree.color(0xff0000ff));
	tree_dirty = true;
	update_tree = true;
})

screen.addEventListener("contextmenu", (e) => e.preventDefault());

let update_screen = () => {
	let n_dim = [screen.clientWidth, screen.clientHeight];

	[screen.width, screen.height] = n_dim;
	gl.viewport(0, 0, ...n_dim);
	unit = 2*Math.max(...n_dim);
	rend.set_uniform("center", "vec2", smul(0.5, n_dim));
	rend.set_uniform("res", "vec2", n_dim);

	redraw = true;
}

addEventListener("resize", update_screen);





let loop = () => {
	if(update_tree){
		update_tree = false;
		redraw = true;
		set_qtree(tree);
	}

	if(redraw){
		redraw = false;
		rend.set_uniform("transform", "mat4", [
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			-pos[0], -pos[1], 0, 1
		]);

		rend.set_uniform("unit", "float", unit/zoom);
		rend.draw();
	}

	requestAnimationFrame(loop);
}









/*init tree*/
let qtree = LinearQtree();

/*
let black = qtree.add_node(0, {ind: 0}, {ind: 0}, {ind: 0}, {ind: 0});
let white = qtree.add_node(0xffffffff, {ind: 1}, {ind: 1}, {ind: 1}, {ind: 1});
let cyan = qtree.add_node(0x00ffff00, {ind: 2}, {ind: 2}, {ind: 2}, {ind: 2});

{
  let a = qtree.add_node(0xffffffff, 0, 0, 0, cyan);
  let b = qtree.add_node(0xffffffff, 0, 0, 0, white);
  let t45 = qtree.add_node(0xffffffff, b, b, b, black);

  a.set_node(0, t45);
  a.set_node(1, a);
  a.set_node(2, b);
  a.set_tag(0xffffffff);

  b.set_node(0, t45);
  b.set_node(1, b);
  b.set_node(2, a);
  b.set_tag(0xffff00ff);

  tree = t45
}

c_tree = tree;
*/

c_tree = qtree.color(0xffffffff);
update_screen();
set_qtree(tree = c_tree);
loop();
	</script>
</html>
