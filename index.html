<!DOCTYPE html>
<html>
	<head>
		<title>da</title>
<style>
* {
	touch-action: none;
}

canvas {
	width: 100%;
	height: 90vh;
}
</style>
	</head>
	<body>
		<canvas id="screen"></canvas>
	</body>
	<script src="input.js"></script>
	<script src="graphics.js"></script>
	<script src="qtree.js"></script>
	<script>
let screen = document.getElementById("screen");
let gl = screen.getContext("webgl");

let rend = FragmentRenderer(gl,
`
precision highp float;
precision highp int;

uniform vec2 res;


uniform vec2 tres;
uniform int ltwidth;
uniform sampler2D tex;

uniform vec2 center;
uniform ivec4 node;
uniform int depth;
uniform float unit;


uniform mat4 transform;

/* 32bit int emulation */
ivec2 moddiv(int a, int b){
	int div = a / b;
	int mod = a - div * b;

	return ivec2(mod, div);
}

ivec4 carry_prop(ivec4 a){
	ivec2 v;

	v = moddiv(a.r, 256);
	a.r = v.x;
	v = moddiv(a.g + v.y, 256);
	a.g = v.x;
	v = moddiv(a.b + v.y, 256);
	a.b = v.x;
	v = moddiv(a.a + v.y, 256);
	a.a = v.x;

	return a;
}

ivec4 rshift8(ivec4 a){
	return ivec4(a.g, a.b, a.a, 0);
}

ivec4 rshift07(ivec4 a, int b){
	int v = int(float(a.r) * pow(0.5, float(b)));
	a = carry_prop(rshift8(a)*int(pow(2.0,float(8-b))));
	a.r = a.r + v;
	return a;
}

ivec4 rshift(ivec4 a, int b){
	ivec2 mul = moddiv(b, 7);
	for(int i = 0; i < 8; i++){
		if(mul.y - i == 0)
			break;
		a = rshift07(a, 7);
	}

	return rshift07(a, mul.x);
}

ivec4 lshift(ivec4 a, int b){
	ivec2 mul = moddiv(b, 7);
	for(int i = 0; i < 8; i++){
		if(mul.y - i == 0)
			break;
		a = carry_prop(a*int(pow(2.0, 7.0)));
	}

	return carry_prop(a*int(pow(2.0, float(mul.x))));
}

ivec4 vec4tonum(vec4 val){
	return ivec4(int(256.0*val.r), int(256.0*val.g), int(256.0*val.b), int(256.0*val.a));
}






vec4 col_at(ivec4 ind){
	ivec4 v2 = rshift(ind, ltwidth);
	ivec4 v1 = ind - lshift(v2, ltwidth);

	//vec2 tc = vec2(v1.r + 256*v1.g, v2.r + 256*v2.g) / tres;

	vec2 tc = (vec2(v1.r + 256*v1.g, v2.r + 256*v2.g) + vec2(0.5)) / tres;
	//tc.y = 1.0 - tc.y;

	return texture2D(tex, tc);
}

ivec4 num_at(ivec4 ind){
	return vec4tonum(col_at(ind));
}



void main(){
	vec2 pos = (transform * vec4(gl_FragCoord.xy, 0.0, 1.0)).xy;
	vec2 orig = center;

	ivec4 ind = node;
	float width = unit;

/*
	if(gl_FragCoord.x < center.x){
		vec2 p = gl_FragCoord.xy/res;
		p.x = p.x * 2.0;
		p.y = 1.0 - p.y;

		gl_FragColor = texture2D(tex, p);
		gl_FragColor.a = 1.0;
		return;
	}
	else{
		vec2 p = gl_FragCoord.xy;

		if(p.y > tres.x * tres.y)
			discard;
		ivec4 ind = carry_prop(ivec4(p.y, 0, 0, 0));

		gl_FragColor = col_at(ind);
		gl_FragColor.a = 1.0;
		return;
	}
	*/


	if(any(greaterThan(abs(pos - orig), vec2(width*0.5))))
		discard;

	for(int i = 0; i < 16; i++){
		if(i >= depth)
			break;

		vec2 quad = vec2(pos.x > orig.x, pos.y < orig.y);
		ind = ind * 5;
		ind.r = ind.r + 1 + int(quad.x + 2.0*quad.y);
		ind = num_at(carry_prop(ind));

		width = width / 2.0;
		orig = vec2(quad.x-0.5, 0.5-quad.y)*width + orig;
	}

	gl_FragColor = col_at(ind*5);
	gl_FragColor.a = 1.0;
}
`
);



let add = (a, b) => a.map((v, i) => v + b[i]);
let smul = (a, b) => b.map(v => v * a);
let sub = (a, b) => add(a, smul(-1, b));
let dot = (a, b) => a.map((v, i) => v * b[i]).reduce((a, b) => a + b);
let length = (a) => dot(a, a)**0.5;
let norm = (a) => smul(1/length(a), a);
let to_cspace = ([x, y]) => [x - screen.width/2, screen.height/2 - y];






/*TODO remove globals*/
let unit;
let pos = [0, 0];
let zoom = 1;
let path = [0n, 0n];
let c_depth = 1n;
let c_tree;
let redraw = false;

let set_qtree = (node) => {
	let depth = Math.log2(unit) + 4 | 0;
	let buffer = sub_tree(node, depth).get_buffer();

	let tex_w = Math.min(gl.getParameter(gl.MAX_TEXTURE_SIZE), 1<<16);
	let num = buffer.length / 4;
	let [w, h] = num < tex_w ? [num, 1] : [tex_w, num / tex_w];

	rend.set_texture("tex", w, h, buffer);
	rend.set_uniform("ltwidth", "int", Math.log2(w));
	rend.set_uniform("tres", "vec2", [w, h]);
	rend.set_uniform("node", "ivec4", [0, 0, 0, 0]);
}

let get_location = () => {
	return `[${pos}], ${zoom}, [${path[0]}n, ${path[1]}n], ${c_depth}n`;
}

let get_tlnode = () => {
	let mask = ~((1n<<c_depth)-1n);

	let path_arr = [
		add(path, [0n, 0n]),
		add(path, [1n, 0n]),
		add(path, [0n, 1n]),
		add(path, [1n, 1n]),
	];

	while(path_arr.flat().some(v => v & mask)){
		let nodes = [white, white, white, white];
		let ind = BigInt((path[0] < 0n) + 2*(path[1] < 0n));

		nodes[ind] = c_tree;
		c_tree = qtree.add_node(0xffffffff, ...nodes);

		let os = smul(1n<<c_depth, [ind&1n,ind>>1n]);

		path_arr = path_arr.map(v => add(v, os));

		path = add(path, os);
		c_depth++;
		mask <<= 1n;
	}

	return qtree.add_node(0xffffffff, ...path_arr.map(v => get_node(c_tree, v, c_depth)));
}


let update_view = (n_pos, n_zoom, n_path, n_depth) => {
	while(1 >= 4*n_zoom){
		n_zoom *= 2;

		n_depth++;
		n_path = add(smul(2n, path), [1n, 1n]);
	}

	while(1 <= n_zoom){
		n_zoom /= 2;

		let os = smul(unit/n_zoom/4, [!(path[0] & 1n), -!(path[1] & 1n)]);
		n_pos = add(n_pos, os);

		n_depth--;
		n_path = [path[0]>>1n, path[1]>>1n];
	}

	let v = smul(-4*n_zoom/unit, n_pos).map(v => Math.sign(v | 0));
	if(v[0] || v[1]){
		n_pos = add(n_pos, smul(unit/(n_zoom*2), v));
		n_path = add(n_path, [BigInt(v[0]), BigInt(-v[1])]);
	}

	let update_tree = false;
	if(n_depth != c_depth || add(path, smul(-1n, n_path)).some(v => v != 0n)){
		update_tree = true;
	}

	pos = n_pos;
	zoom = n_zoom;
	path = n_path;
	c_depth = n_depth;

	if(update_tree)
		set_qtree(get_tlnode());

	redraw = true;
}

/* event listeners */
mouse_wheel(screen, ([x, y], change) => {
	let dp = to_cspace([x, y]);
	let n_zoom = zoom + 0.05*zoom*change;

	update_view(
		add(smul(zoom/n_zoom, sub(pos, dp)), dp),
		n_zoom,
		path, 
		c_depth
	);
});
touch_pinch(screen, ([x, y], change) => {
	let dp = to_cspace([x, y]);
	let n_zoom = zoom + 0.05*zoom*change;

	update_view(
		add(smul(zoom/n_zoom, sub(pos, dp)), dp),
		n_zoom,
		path, 
		c_depth
	);
});


mouse_pan(screen, () => pos, (n_pos) => update_view(n_pos, zoom, path, c_depth));
touch_pan(screen, () => pos, (n_pos) => update_view(n_pos, zoom, path, c_depth));

screen.addEventListener("contextmenu", (e) => e.preventDefault());

let update_screen = () => {
	let n_dim = [screen.clientWidth, screen.clientHeight];

	[screen.width, screen.height] = n_dim;
	gl.viewport(0, 0, ...n_dim);
	unit = 2*Math.max(...n_dim);
	rend.set_uniform("center", "vec2", smul(0.5, n_dim));
	rend.set_uniform("res", "vec2", n_dim);
	rend.set_uniform("depth", "int", Math.log2(unit) + 4 | 0);

	redraw = true;
}

addEventListener("resize", update_screen);





let loop = () => {

	if(redraw){
		redraw = false;
		rend.set_uniform("transform", "mat4", [
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			-pos[0], -pos[1], 0, 1
		]);

		rend.set_uniform("unit", "float", unit/zoom);
		rend.draw();
	}

	requestAnimationFrame(loop);
}









/*init tree*/
let qtree = LinearQtree();

let black = qtree.add_node(0, {ind: 0}, {ind: 0}, {ind: 0}, {ind: 0});
let white = qtree.add_node(0xffffffff, {ind: 1}, {ind: 1}, {ind: 1}, {ind: 1});
let cyan = qtree.add_node(0x00ffff00, {ind: 2}, {ind: 2}, {ind: 2}, {ind: 2});

{
  let a = qtree.add_node(0xffffffff, 0, 0, 0, cyan);
  let b = qtree.add_node(0xffffffff, 0, 0, 0, white);
  let t45 = qtree.add_node(0xffffffff, b, b, b, black);

  a.set_node(0, t45);
  a.set_node(1, a);
  a.set_node(2, b);
  a.set_tag(0xffffffff);

  b.set_node(0, t45);
  b.set_node(1, b);
  b.set_node(2, a);
  b.set_tag(0xffff00ff);

  tree = t45
}

c_tree = tree;
update_screen();
set_qtree(tree);
loop();
	</script>
</html>
