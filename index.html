<!DOCTYPE html>
<html>
	<head>
		<title>da</title>
		<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
	</head>
	<body></body>
	<script src="src/input.js"></script>
	<script src="src/graphics.js"></script>
	<script src="src/qtree.js"></script>
	<script src="src/component.js"></script>
	<script src="src/brush.js"></script>
	<script src="src/networking.js"></script>
	<script>

let add = (a, b) => a.map((v, i) => v + b[i]);
let smul = (a, b) => b.map(v => v * a);
let sub = (a, b) => add(a, smul(-1, b));
let dot = (a, b) => a.map((v, i) => v * b[i]).reduce((a, b) => a + b);
let length = (a) => dot(a, a)**0.5;
let norm = (a) => smul(1/length(a), a);
let clamp = (v, a, b) => Math.min(Math.max(v, a), b);

/*task queue*/

let IdempotentTaskQueue = () => {
	let tasks = [];
	let skip = new Set();
	let task_set = new Set();
	let ind = 0;

	let obj = {
add_task_:  (name, fn) => tasks.push([name, fn]),
add_task: (name, fn) => {
	if(!task_set.has(name)){
		obj.add_task_(name, fn);
		task_set.add(name);
	}
},
skip: (name) => skip.add(name), //TODO this is gross, plz fix
get_task: () => {
	if(ind == tasks.length){
		tasks = [];
		ind = 0;
		return null;
	}

	let [name, fn] = tasks[ind];
	delete tasks[ind++];
	task_set.delete(name);

	if(skip.has(name)){
		skip.delete(name);
		return obj.get_task();
	}
	return [name, fn];
}
	}

	return obj;
}





/*TODO remove globals*/

//frame task stuff
let taskList = IdempotentTaskQueue();
let queue = [];
let seen = new Map();


//rendering stuff
let rend, gpu_buf;
let unit;
let pos = [0, 0];
let zoom = 1;
let res;

let qtree, path;


let brush = SdfBrush();
let global_depth = 0;
let drawing = false;


// undo stuff
let undo_queue = [
//[path, pos, zoom, surface]
];

let redo_queue = [];

let get_state = () => [path.copy(), [...pos], zoom, qtree.node_at(brush.get_surface()[1].ind), global_depth];

let load_state = (state) => {
	let surface;
	[path, pos, zoom, surface, global_depth] = state;
	gpu_buf.clear();
	let gpu_t = LinearQtree(gpu_buf);
	let stree = QtreeMirror(qtree, gpu_t);

	brush.set_surface(stree, stree.node_at(surface.ind));
	set_qtree(stree.mirror(surface));

	queue = [surface.ind, 0];
	seen = new Map();
};

let undo = () => {
	if(undo_queue.length){
		let state = undo_queue.pop();
		redo_queue.push(get_state());
		load_state(state);
	}
}

let redo = () => {
	if(redo_queue.length){
		let state = redo_queue.pop();
		undo_queue.push(get_state());
		load_state(state);
	}
}

/* tree helper functions */

let set_qtree = (node) => {
	let depth = Math.min(Math.log2(unit) + 2 | 0, 16);
	
	rend.set_uniform("depth", "int", depth);
	rend.set_uniform("node", "ivec4", [
		(node.ind >> 0) & 0xff,
		(node.ind >> 8) & 0xff,
		(node.ind >> 16) & 0xff,
		(node.ind >> 24) & 0xff
	]);
}

let get_tlnode = () => {
	let offsets = [
		[[1n, 0n], 0],
		[[0n, 1n], 1],
		[[-1n, 0n], 3],
		[[0n, -1n], 2]
	];

	let nodes = Array(4).fill();
	offsets.forEach(([v, i]) => {
		nodes[i] = path.cur();
		path.add(v);
	});

	//TODO don't actually initialize unaligned nodes
	return qtree.node(...nodes);
}


let set_tlnode = (node) => {
	let offsets = [
		[[1n, 0n], 0],
		[[0n, 1n], 1],
		[[-1n, 0n], 3],
		[[0n, -1n], 2]
	];

	offsets.forEach(([v, i]) => {
		path.set_cur(node.get_node(i));
		path.add(v);
	});
}






















let redraw = () => {
	rend.set_uniform("transform", "mat4", [
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		-pos[0], -pos[1], 0, 1
	]);

	rend.set_uniform("unit", "float", unit/zoom);
	rend.draw();
};

let update_tree = () => {
	drawing = false;

	let [stree, node] = brush.get_surface();
	set_qtree(stree.mirror(node));

	taskList.add_task("redraw", redraw);
};





let update_view = (update = false) => {
	if(brush.dirty()){
		let [stree, node] = brush.get_surface();
		set_tlnode(node);
		brush.clean();
	}

	while(1 >= 4*zoom){
		zoom *= 2;
		path.desc(3);
		update = true;

		global_depth++;
	}

	while(1 < zoom){
		zoom /= 2;
		let ind = path.cur_ind();
		let os = smul(unit/zoom/4, [!(ind & 1), -!(ind & 2)]);
		pos = add(pos, os);
		path.asc(0);
		update = true;

		global_depth--;
	}

	while(1){
		let v = smul(-4*zoom/unit, pos).map(v => Math.sign(v | 0));
		if(v[0] || v[1]){
			pos = add(pos, smul(unit/(zoom*2), v));
			path.add([BigInt(v[0]), BigInt(-v[1])]);
			update = true;
			continue;
		}

		break;
	}

	taskList.add_task("redraw", redraw);
	if(update){
		gpu_buf.clear();
		let gpu_t = LinearQtree(gpu_buf);
		let stree = QtreeMirror(qtree, gpu_t);
		let node = stree.node_at(get_tlnode().ind);

		brush.set_surface(stree, node);
		set_qtree(stree.mirror(node));

		queue = [node.ind, 0];
		seen = new Map();

		drawing = false;
		taskList.skip("redraw");
	}

}



let loop = (() => {
	let frame_start = performance.now(); //I love closures
	let avg_frame_time = 16;

	return () => {
		let start = performance.now();
		let time = () => performance.now() - start;

		let frame_time = start - frame_start;
		if(frame_time < 10 * avg_frame_time)
			avg_frame_time = Math.max((9*frame_time + frame_time) / 10, 1); //firefox gets this set to zero somehow...
		frame_start = start;


		let task;
		while(time() < avg_frame_time * 0.8 && (task = taskList.get_task()))
			task[1]();

		let max_depth = Math.min(Math.log2(unit) + 2 | 0, 16);
		//let seen = cursor_path.get_tree().get_seen(); //TODO use mirror's seen?
		let nodes = [];
		if(queue.length){
			while(time() < avg_frame_time * 0.5 && queue.length){
				let nd = brush.get_tree().node_at(queue.shift());
				let depth = queue.shift();

				if(seen.has(nd.ind) || depth >= max_depth)
					continue;

				seen.set(nd.ind, depth);
				for(let i = 0; i < 4; i++)
					queue.push(nd.get_node(i ^ depth & 3).ind, depth + 1);

				delete nd;
			}

			taskList.add_task("update_tree", update_tree);
		}

		requestAnimationFrame(loop);
	}
})();




















(async () => {
	document.body = un_cps(Body(
		Overlap(
			//canvas
			Block(
				all(
					el("canvas"),
					Attr("id", "screen")
				)
			),

			//top bar
			Rect("100%", "4em")(
				all(
					Border(row(
						all(
							el("input"),
							Attr("type", "color"),
							Event("input", (e) => {
								let rgb = e.srcElement.value.slice(1);
								brush.set_color(+("0xff" + rgb.match(/.{2}/g).toReversed().join("")));
							})
						),
						all(
							el("input"),
							Attr("type", "number"),
							Event("input", (e) => {
								drawing = false;
								brush.set_scale(+e.srcElement.value);
							})
						)
					)),
					Style({
						"background": "white"
					})
				)
			)
		)
	))();


	let screen = document.getElementById("screen");
	let gl = screen.getContext("webgl");

	/* event listeners */
	let to_cspace = ([x, y]) => [x - res[0]*0.5, res[1]*0.5 - y];
	mouse_wheel(screen, ([x, y], change) => {
		let dp = to_cspace([x, y]);
		let n_zoom = zoom + 0.05*zoom*change;
		pos = add(smul(zoom/n_zoom, sub(pos, dp)), dp),
		zoom = n_zoom;

		taskList.add_task("update_view", update_view);
	});
	touch_pinch(screen, (p, change) => {
		let dp = to_cspace(p);
		let n_zoom = zoom + 0.05*zoom*change;

		zoom = n_zoom;
		taskList.add_task("update_view", update_view);
	});

	mouse_pan(screen, () => pos, (n_pos) => {
		pos = n_pos
		taskList.add_task("update_view", update_view);
	});
	touch_pan(screen, () => pos, (n_pos) => {
		pos = n_pos;
		taskList.add_task("update_view", update_view);
	});





	let to_uvspace = (p) => smul(zoom/unit, sub(to_cspace(p), pos));
	pointer_drag(screen, (p) => {
		undo_queue.push(get_state());
		redo_queue = [];

		taskList.add_task_("draw", () => {
			brush.set_pos(to_uvspace(p), global_depth);
			drawing = true;
			taskList.add_task("update_tree", update_tree);
		});
	},(p, k) => {
		taskList.add_task_("draw", () => {
			if(!drawing){
				brush.set_pos(to_uvspace(p), global_depth);
				drawing = true;
			}

			brush.update_pos(to_uvspace(p), smul(zoom/unit, [k[0], k[1]]));
			taskList.add_task("update_tree", update_tree);
		});
	});

	let update_screen = () => {
		let n_dim = [screen.clientWidth, screen.clientHeight];

		[screen.width, screen.height] = n_dim;
		res = n_dim;
		gl.viewport(0, 0, ...n_dim);
		unit = 2*Math.max(...n_dim);
		rend.set_uniform("center", "vec2", smul(0.5, n_dim));
		rend.set_uniform("res", "vec2", n_dim);

		taskList.add_task("redraw", redraw);
	};

	addEventListener("resize", update_screen);


	let keys = {};
	Keyboard(window, (key) => {
		keys[key] = true;
		if(keys[70]){
			rend.set_uniform("debug", "int", 1);
			taskList.add_task("redraw", redraw);
		}

		if(keys[90] && keys[17]){
			undo();
		}

		if(keys[89] && keys[17]){
			redo();	
		}
	}, (key) => {
		keys[key] = false;
		if(key == 70){
			rend.set_uniform("debug", "int", 0);
			taskList.add_task("redraw", redraw);
		}
	});


	let shader = await fetch("src/tree_shader.glsl").then(v => v.text());
	rend = FragmentRenderer(gl, shader);

	/*init tree*/
	rend.set_active();
	qtree = LinearQtree();

	path = QtreePath(qtree, qtree.color(0xffffffff));
	path.set_path([0n, 0n], 1n);

	update_screen();
	rend.set_uniform("debug", "int", 0);

	gpu_buf = Uint32Arr(rend.GpuUint8("tex"));
	let gpu_t = LinearQtree(gpu_buf);
	let mirror = QtreeMirror(qtree, gpu_t);
	let node = mirror.node_at(get_tlnode().ind);

	brush.set_surface(mirror, node);
	set_qtree(mirror.mirror(node));
	loop();
})()
	</script>
</html>
